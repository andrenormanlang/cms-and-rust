{
  "title": "Rust: Ownership and Borrowing Explained",
  "excerpt": "A brief look at Rust's core concepts of ownership, borrowing, and lifetimes, which guarantee memory safety without a garbage collector.",
  "content": "# Rust: Ownership and Borrowing Explained\n\nRust is a modern systems programming language focused on **safety, speed, and concurrency**. One of its most unique and defining features is its ownership system, which manages memory safety without needing a garbage collector.\n\n## The Core Concepts\n\n1.  **Ownership:** Each value in Rust has a variable that's called its *owner*. There can only be one owner at a time. When the owner goes out of scope, the value will be dropped (memory is freed).\n\n2.  **Borrowing:** Instead of transferring ownership, you can *borrow* a reference to a value. References are immutable by default (`&T`). You can also have mutable references (`&mut T`), but with strict rules:\n    *   You can have either one mutable reference *or* any number of immutable references in a particular scope.\n    *   References must always be valid.\n\n3.  **Lifetimes:** Lifetimes are a way for the compiler to ensure that references are valid for as long as they are needed. They prevent *dangling references* (references pointing to memory that has been freed).\n\n## Why is this important?\n\nThis system allows Rust to guarantee memory safety (no null pointer exceptions, no data races in safe Rust) at *compile time*. This means potential memory bugs are caught before the program even runs, without the runtime overhead of garbage collection found in languages like Java or Go.\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    // let s2 = s1; // Ownership moves from s1 to s2\n    // println!(\"{}\", s1); // This would cause a compile-time error!\n\n    let len = calculate_length(&s1); // s1 is borrowed immutably\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because it does not have ownership,\n  // nothing happens.\n```\n\nUnderstanding ownership and borrowing is fundamental to writing idiomatic and effective Rust code. While it might seem complex initially, it's the key to Rust's powerful guarantees.\n\n{image_id} *Rust logo (Ferris the crab)*"
}
